<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Homenagem Alphacampus</title>
    <!-- Fonte Arial (Padrão) -->
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background-color: #004d40; 
            background-image: url('background.jpeg'); 
            background-size: contain; /* Tenta 'contain' para garantir que a imagem inteira apareça */
            background-position: center; /* Centraliza a imagem */
            background-repeat: no-repeat; /* Evita a repetição da imagem */
            filter: none; /* Remove o filtro para garantir que a imagem apareça */
            color: #D4B851; /* Cor Amarelo-Ouro extraída da imagem */
            font-family: Arial, sans-serif; /* Mantido em Arial */ 
            display: flex; 
            flex-direction: column; 
            justify-content: center; 
            align-items: center; 
            height: 100vh; 
            overflow: hidden; 
            text-align: center; 
        }
	        #name-container { 
	            font-size: 4vw; 
	            font-weight: 700; 
	            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5); 
	            transition: opacity 1s ease-in-out; 
	            padding: 20px; 
	            max-width: 90%; 
	            flex: 1; 
	            display: flex; 
	            align-items: center; 
	            justify-content: center; 
	            flex-direction: column; /* Adicionado para alinhar nome e localização verticalmente */
	            line-height: 1.2; /* Ajuste para melhor espaçamento vertical */
	            /* Aplica a animação de flutuação */
	            animation: float 4s ease-in-out infinite;
	        }
        #name-container .name {
            font-size: 1em;
        }
        #name-container .location {
            font-size: 0.5em; /* Localização menor */
            opacity: 0.7;
        }
        .fade-in { opacity: 1; }
	        .fade-out { opacity: 0; }
	
	        /* Animação de Flutuação (Dança) */
		        @keyframes float {
		            0% { transform: translateY(0); }
		            50% { transform: translateY(-5px); } /* Move 5px para cima */
		            100% { transform: translateY(0); }
		        }
		
		        /* Estilos para as palavras que dançam */
		        .dancing-word {
		            display: inline-block; /* Essencial para aplicar transformações */
		            /* A animação de delay será injetada via JavaScript para um efeito de onda */
		            animation: wordDance 1.5s ease-in-out infinite;
		        }
		
		        /* Animação de Dança (Pulo/Balanço) */
		        @keyframes wordDance {
		            0%, 100% { transform: translateY(0) rotate(0deg); }
		            25% { transform: translateY(-8px) rotate(2deg); }
		            75% { transform: translateY(8px) rotate(-2deg); }
		        }
		        
		        /* Mantendo o float para o container, mas o foco agora é no wordDance */
		        
		        /* Animação de Flutuação (Dança) */
	        @keyframes float {
	            0% { transform: translateY(0); }
	            50% { transform: translateY(-5px); } /* Move 5px para cima */
	            100% { transform: translateY(0); }
	        }
	
		        button { padding: 12px 30px; font-size: 1.2vw; font-weight: bold; color: #004d40; background-color: #D4B851; border: none; border-radius: 5px; cursor: pointer; transition: background-color 0.3s ease, transform 0.2s ease; font-family: Arial, sans-serif; }
	        button:hover { background-color: #C1A748; /* Tom mais escuro para o hover */ transform: scale(1.05); }
	        button:active { transform: scale(0.95); }
	        button:disabled { background-color: #999; cursor: not-allowed; opacity: 0.6; }
	
	        /* Novos estilos para o container dos botões, que agora será o único elemento na parte inferior */
		        #button-container {
		            display: flex;
		            gap: 20px;
		            justify-content: center;
		            align-items: center;
		            /* Remove o padding, background e border-top para eliminar a faixa */
		            width: 100%;
		            /* Adiciona um espaço para que os botões não fiquem colados no fundo */
		            padding-bottom: 20px;
		        }
	
	        /* Classe para ocultar os botões */
	        .hidden-controls {
	            visibility: hidden;
	            opacity: 0;
	            transition: visibility 0s 0.3s, opacity 0.3s ease;
	        }
	
	        /* Mostrar os botões quando o mouse estiver sobre a área dos botões */
	        #button-container:hover.hidden-controls {
	            visibility: visible;
	            opacity: 1;
	            transition: opacity 0.3s ease;
	        }
	        
	        /* Garante que os botões em si não tenham transições desnecessárias */
	        #button-container button {
	            transition: none;
	        }
	        
    </style>
</head>
<body>
		    <div id="name-container">Carregando nomes...</div>
		        <div id="button-container" class="hidden-controls">
			            <button id="play-btn" disabled>▶ Play</button>
			            <button id="pause-btn" disabled>⏸ Pause</button>
			            <button id="fullscreen-btn">⛶ Tela Cheia</button>
		        </div>
		    <script>
        let names = [];
        // CORREÇÃO: Usar ponto (.) como separador decimal em JavaScript (0.5 * 1000)
        const durationPerName = 0.5 * 1000; 
        const transitionTime = 1000;
	        const container = document.getElementById('name-container');
	        const playBtn = document.getElementById('play-btn');
	        const pauseBtn = document.getElementById('pause-btn');
	        const fullscreenBtn = document.getElementById('fullscreen-btn'); // Novo botão de tela cheia
	        const buttonContainer = document.getElementById('button-container'); // Novo elemento container dos botões
	        // const progressFill = document.getElementById('progress-fill'); // Removido
	        // const currentNameNumber = document.getElementById('current-name-number'); // Removido
	        // const totalNamesEl = document.getElementById('total-names'); // Removido

        let currentIndex = 0;
        let isPlaying = false;
        let timeoutId = null;
        let transitionTimeoutId = null;

        /**
         * Processa a string de nome e localização para retornar um objeto estruturado.
         * Ex: "NOME COMPLETO - Setor:1Jazigo:73Quadra:EUCALIPTOS"
         * Retorna: { name: "NOME COMPLETO", location: "Setor: 1 | Jazigo: 73 | Quadra: EUCALIPTOS" }
         */
        function parseNameAndLocation(fullString) {
            const parts = fullString.split(' - ');
            const name = parts[0] || 'Nome Desconhecido';
            let location = parts[1] || '';

            // Adiciona espaços e barras para formatar a localização
            location = location
                .replace(/Setor:/g, 'Setor: ')
                .replace(/Jazigo:/g, ' | Jazigo: ')
                .replace(/Quadra:/g, ' | Quadra: ');

            // Remove o primeiro " | " se existir
            if (location.startsWith(' | ')) {
                location = location.substring(3);
            }

            return { name, location };
        }

        // Função para envolver cada palavra com um <span> para animação
function wrapTextWithSpans(text) {
    // Substitui o espaço normal por um espaço não-quebrável após a palavra
    // para que a animação não quebre a linha.
    return text.split(' ').map((word, index) => {
        return `<span class="dancing-word" style="animation-delay: ${index * 0.05}s">${word}</span>`;
    }).join('&nbsp;'); // Usa &nbsp; para manter o espaçamento entre as palavras
}

// Função para exibir o nome e a localização no container
        function displayCurrentName() {
            const data = names[currentIndex];
            const parsed = parseNameAndLocation(data);
            
            // Usar innerHTML para criar duas linhas (nome e localização)
            const nameHtml = wrapTextWithSpans(parsed.name);
            const locationHtml = wrapTextWithSpans(parsed.location);
            container.innerHTML = `
                <div class="name">${nameHtml}</div>
                <div class="location">${locationHtml}</div>
            `;
        }

        // Carrega os nomes do arquivo JSON
	        
        fetch('names.json') 
            .then(response => {
                if (!response.ok) {
                    throw new Error('Erro ao carregar names.json: ' + response.statusText);
                }
                // CORREÇÃO: O JSON é um array de strings, não um objeto com a chave 'names'.
                return response.json(); 
            })
            .then(data => {
                // O JSON já é o array de nomes
	                names = data; 
	                // totalNamesEl.textContent = names.length; // Removido
	                playBtn.disabled = false;
                
                // Exibe o primeiro nome imediatamente
                if (names.length > 0) {
                    currentIndex = 0; // Garante que o índice começa em 0
                    displayCurrentName();
                    container.style.opacity = 1; 
                } else {
	                container.textContent = "Lista de nomes vazia.";
	                }
	                
	                playBtn.disabled = false;
	                pauseBtn.disabled = true;
	                
	            })
            .catch(error => {
                console.error("Erro ao carregar a lista de nomes:", error);
                container.textContent = "Erro ao carregar nomes. Verifique se o arquivo names.json está na mesma pasta.";
	            });
	
		        // Funções de atualização de contador e barra de progresso removidas.
		

	
	        // Função para alternar o modo de tela cheia
	        function toggleFullscreen() {
	            if (!document.fullscreenElement) {
	                document.documentElement.requestFullscreen();
	                fullscreenBtn.innerHTML = "⛶ Sair da Tela Cheia";
	            } else {
	                if (document.exitFullscreen) {
	                    document.exitFullscreen();
	                    fullscreenBtn.innerHTML = "⛶ Tela Cheia";
	                }
	            }
	        }
	
	        function showNextName() {
            if (!isPlaying) return;

            // Se o índice atual for o último, paramos e exibimos a mensagem final
            if (currentIndex >= names.length - 1) { 
                // 1. Fade-out do último nome
                container.classList.remove('fade-in');
                container.classList.add('fade-out');

                // 2. Mudar para a mensagem final após o tempo de transição
                transitionTimeoutId = setTimeout(() => {
                    container.innerHTML = "Em Memória de Todos os Falecidos";
                    container.classList.remove('fade-out');
	                    container.classList.add('fade-in');
	                    isPlaying = false;
	                    playBtn.disabled = false;
	                    pauseBtn.disabled = true;
	                    // Contagem e barra de progresso removidas.
	                }, transitionTime);
                
                return;
            }
            
            // Avança para o próximo índice
            currentIndex++;
            
            // 1. Fade-out do nome anterior
            container.classList.remove('fade-in');
            container.classList.add('fade-out');

            // 2. Mudar o nome e fazer fade-in após o tempo de transição
            transitionTimeoutId = setTimeout(() => {
	                displayCurrentName();
	                container.classList.remove('fade-out');
	                container.classList.add('fade-in');
	                // updateCounter() e updateProgressBar() removidas.
	                // Agenda o próximo showNextName
                timeoutId = setTimeout(showNextName, durationPerName); 
            }, transitionTime);
        }

	        function play() {
	            if (isPlaying) return;
	            
	            isPlaying = true;
	            playBtn.disabled = true;
		            pauseBtn.disabled = false;
	            
	            // Se já tiver terminado, recomeça do início
            if (currentIndex >= names.length - 1) { 
                currentIndex = -1; // -1 para que o showNextName comece no 0
                container.classList.remove('fade-in');
                container.classList.remove('fade-out');
            }
            
            // Inicia o ciclo
            showNextName();
        }

	        function pause() {
	            if (!isPlaying) return;
	            isPlaying = false;
		            playBtn.disabled = false;
		            pauseBtn.disabled = true;
	            clearTimeout(timeoutId);
	            clearTimeout(transitionTimeoutId);
	        }

	        playBtn.addEventListener('click', play);
	        pauseBtn.addEventListener('click', pause);
	        fullscreenBtn.addEventListener('click', toggleFullscreen); // Adiciona listener para o botão de tela cheia
	        
				        // A lógica de hover no CSS já garante que os botões apareçam
				        // quando o mouse estiver sobre a div #button-container.
				        
				        // O container de botões já começa com a classe 'hidden-controls' no HTML.
				        // Para permitir o primeiro play, precisamos garantir que a classe seja removida 
				        // após o carregamento dos nomes, mas sem a função showButtons.
				        // Vamos remover a classe 'hidden-controls' do container no HTML para que os botões
				        // fiquem visíveis inicialmente. O CSS de hover será ajustado para funcionar ao contrário.
				        // Ou, mais simples: Deixar a classe no HTML e remover a chamada showButtons() no final.
				        // Como o usuário quer que eles apareçam no hover, a classe deve permanecer.
				        // O usuário precisa ver o botão "Play" para começar. Vamos manter a classe no HTML
				        // e confiar no CSS de hover, mas o botão "Play" precisa estar visível inicialmente.
				        // A melhor solução é remover a classe 'hidden-controls' do HTML e adicionar uma nova
				        // classe de ocultação/exibição via JS, mas o usuário quer o hover.
				        
				        // SOLUÇÃO: Vamos remover a classe 'hidden-controls' do HTML (Linha 124)
				        // e ajustar o CSS para ocultar por padrão e mostrar no hover.
				        // Mas o CSS já faz isso. O problema é que o JS estava chamando showButtons() no final.
				        // Apenas remover a chamada showButtons() no final deve resolver.
	    </script>
</body>
</html>
